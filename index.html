<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MagikarpLL的平行宇宙</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="个人技术博客,日记随笔,摄影分享">
<meta property="og:type" content="website">
<meta property="og:title" content="MagikarpLL的平行宇宙">
<meta property="og:url" content="https://magikarpll.com/index.html">
<meta property="og:site_name" content="MagikarpLL的平行宇宙">
<meta property="og:description" content="个人技术博客,日记随笔,摄影分享">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="MagikarpLL">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="MagikarpLL的平行宇宙" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MagikarpLL的平行宇宙</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这一切都是，命运石之门的选择</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://magikarpll.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="backend-微服务认证方案设计之spring-security-oauth（二）" class="h-entry article article-type-backend" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E4%B9%8Bspring-security-oauth%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-09-01T16:46:39.000Z" itemprop="datePublished">2021-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E4%B9%8Bspring-security-oauth%EF%BC%88%E4%BA%8C%EF%BC%89/">微服务认证方案设计之spring-security-oauth（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>上一章节中，我们介绍了大体的概念。这一章节将主要讲解oauth2.0 + jwt + spring security的开发知识</p>
</blockquote>
<h2 id="整体技术框架"><a href="#整体技术框架" class="headerlink" title="整体技术框架"></a>整体技术框架</h2><ul>
<li>认证中心（授权服务器）: spring security oauth 2.1.2.RELEASE</li>
<li>鉴权框架: spring security 5.3.8.RELEASE</li>
<li>认证协议: oauth2.0</li>
<li>无状态令牌: jwt</li>
</ul>
<h3 id="认证中心框架选择"><a href="#认证中心框架选择" class="headerlink" title="认证中心框架选择"></a>认证中心框架选择</h3><h4 id="方案一-升级现有的cas4-3至cas6-x版本"><a href="#方案一-升级现有的cas4-3至cas6-x版本" class="headerlink" title="方案一: 升级现有的cas4.3至cas6.x版本:"></a>方案一: 升级现有的cas4.3至cas6.x版本:</h4><p>总体上来说,6.x版本cas从功能上来说是满足我们的要求的，但是cas6.x有以下不足，让我最终放弃了使用它:</p>
<ul>
<li>采用了gradle作为包管理器，而项目组现在只用maven，</li>
<li>6.x版本的cas将包拆分的过于细了，导致阅读与寻找源码并不方便，</li>
<li>cas6.x官方并不推荐也不支持你去修改它的登录流程，自定义流程太麻烦了</li>
</ul>
<p>综上，cas6.x适合那些登录流程简单较为固定，需要开箱即用的项目，不适合那些需要自定义修改很多内容的项目。对于企业应用来说，它推荐的使用方式是war包overlay部署方式，里面强塞了太多不需要的东西，太沉重了</p>
<p>还有一点，6.x版本的cas中文文档与博客极少，遇到问题只能看源码，比较痛苦。</p>
<h4 id="方案二-采用spring-security-oauth"><a href="#方案二-采用spring-security-oauth" class="headerlink" title="方案二: 采用spring-security-oauth"></a>方案二: 采用spring-security-oauth</h4><p>虽然spring-security-oauth已经进入了维护阶段，后续官方将废弃该项目，现在spring官方已经将spring-security-oauth中的大部分功能(除了认证服务器)合并入了spring-security中统一管理，后续官方将为认证服务器单独推出一个全新的项目: <a target="_blank" rel="noopener" href="https://github.com/spring-projects-experimental/spring-authorization-server">spring-authorization-server</a>。它目前还处于实验阶段，所以不敢采用。</p>
<p>而spring-security-oauth作为认证中心，虽然已经进入了停止更新状态，但官方依然会维护一段时间。并且作为一个很成熟的spring框架，它预留了很多的方法来供我们自定义，修改起来非常方便。并且设计上也很简单清爽，便于阅读，中文文档和博客也是很多的，所以我采用了这个框架作为我们的认证中心。</p>
<h3 id="鉴权框架选择"><a href="#鉴权框架选择" class="headerlink" title="鉴权框架选择"></a>鉴权框架选择</h3><p>shiro 和 spring-security在功能上都是很好的框架，但Shiro 最大的问题在于和 Spring 家族的产品进行整合的时候非常不便，对比之下，虽然spring-security相对Shiro会复杂很多,但基于 Spring Boot/Spring Cloud 的微服务项目基本上是原生支持spring-security的，对接起来非常方便。因此选择spring-security。</p>
<h3 id="认证协议与令牌方案"><a href="#认证协议与令牌方案" class="headerlink" title="认证协议与令牌方案"></a>认证协议与令牌方案</h3><p>oauth2.0+jwt, oauth2.0只是一种认证协议，具体的令牌方案目前最流行的就是自解析的jwt，很适合微服务方案。</p>
<blockquote>
<p>问题:  假如微服务框架使用非自解析的令牌，相对于jwt有什么优势又有什么劣势呢?</p>
</blockquote>
<hr>
<p>==优势: 安全性更高，对令牌的控制更方便   劣势: 后端服务器压力大，一次认证流程中会有更多的http请求== </p>
<h2 id="具体技术讲解"><a href="#具体技术讲解" class="headerlink" title="具体技术讲解"></a>具体技术讲解</h2><blockquote>
<p>oauth2.0与jwt非常简单，这里就不仔细讲了。主要说一下认证中心与鉴权框架。</p>
</blockquote>
<h3 id="demo演示-几种模式及其参数解释"><a href="#demo演示-几种模式及其参数解释" class="headerlink" title="demo演示(几种模式及其参数解释)"></a>demo演示(几种模式及其参数解释)</h3><blockquote>
<p>这里推荐一个个人认为很好的demo, <a target="_blank" rel="noopener" href="https://gitee.com/copoile/springcloud-oauth2">地址如下</a></p>
</blockquote>
<p>这个项目拉下来直接就可以跑，不需要配置任何数据库，按照readme中的提示一步步跑起来，然后主要要体会一下它的几种模式的调用和弄清楚它各个模式里面的参数都代表什么意思，代码原理倒不怎么用看</p>
<ul>
<li>密码模式</li>
</ul>
<p>密码模式请求的是 /oauth/token 这个接口，一共有五个参数：  </p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>位置</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>username</td>
<td>Authorization中Type为Basic Auth的username选项</td>
<td>对应于oauth服务端中注册好的clientId</td>
<td>无论是哪个客户端接入都必须提前注册clientId和clientSecret</td>
</tr>
<tr>
<td>password</td>
<td>Authorization中Type为Basic Auth的password选项</td>
<td>对应于oauth服务端中注册好的clientSecret</td>
<td>同上</td>
</tr>
<tr>
<td>username</td>
<td>Body中</td>
<td>用户名</td>
<td>无</td>
</tr>
<tr>
<td>password</td>
<td>Body中</td>
<td>密码</td>
<td>无</td>
</tr>
<tr>
<td>grant_type</td>
<td>Body中</td>
<td>授权类型</td>
<td>这个参数决定你调用的是哪种模式，密码模式为password</td>
</tr>
</tbody></table>
<ul>
<li>授权码模式</li>
</ul>
<p>第一步，浏览器访问这个地址 <a target="_blank" rel="noopener" href="http://localhost:8001/oauth/authorize?response_type=code&amp;scope=sever&amp;client_id=yaohw&amp;redirect_uri=http://www.baidu.com&amp;state=0583">http://localhost:8001/oauth/authorize?response_type=code&amp;scope=sever&amp;client_id=yaohw&amp;redirect_uri=http://www.baidu.com&amp;state=0583</a> 然后会重定向到登录页</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>response_type</td>
<td>授权码模式固定为code</td>
</tr>
<tr>
<td>scope</td>
<td>请求的token的作用范围</td>
</tr>
<tr>
<td>client_id</td>
<td>在oauth2认证中心注册的客户端Id</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>登录成功后的重定向地址，该地址必须与在oauth2认证中心注册的重定向地址完全一致</td>
</tr>
<tr>
<td>state</td>
<td>自定义参数，忽略</td>
</tr>
</tbody></table>
<p>第二步，在页面输入用户名和密码，就会带着授权码?code=xxx跳转到上面哪个地址，将授权码拷贝下来</p>
<p>第三步，post访问<a target="_blank" rel="noopener" href="http://localhost:8001/oauth/token,%E5%8F%82%E6%95%B0%E5%A6%82%E4%B8%8B">http://localhost:8001/oauth/token,参数如下</a></p>
<blockquote>
<p>访问/oauth/token时候，请求头Authorization中都必须配置Type为Basic Auth,然后将clientId和clientSecret设入，后面就不讲解这个了</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>grant_type</td>
<td>这里对应获取token的模式，授权码模式必须为authorization_code</td>
</tr>
<tr>
<td>code</td>
<td>上一步获取的授权码</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>登录成功后的重定向地址，该地址必须与在oauth2认证中心注册的重定向地址完全一致</td>
</tr>
</tbody></table>
<blockquote>
<p>下面三种模式就不多说了，你们可以仔细观察下调用的几个接口的区别，可以发现以下几点区别</p>
</blockquote>
<p>只要是前端页面跳转，都是调用<a target="_blank" rel="noopener" href="http://localhost:8001/oauth/authorize?response_type=%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%AF%E9%80%9A%E8%BF%87response_type%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E6%9D%A5%E5%8C%BA%E5%88%86%E6%A8%A1%E5%BC%8F">http://localhost:8001/oauth/authorize?response_type=这个地址，并且是通过response_type这个参数来区分模式</a></p>
<p>而如果是后端接口调用，则是通过<a target="_blank" rel="noopener" href="http://localhost:8001/oauth/token%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E6%9D%A5%E8%B0%83%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%80%9A%E8%BF%87grant_type%E8%BF%99%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%9D%A5%E5%8C%BA%E5%88%86%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%80%E5%AE%9A%E5%B8%A6%E6%9C%89clientId%E5%92%8CclientSecret">http://localhost:8001/oauth/token这个接口来调用，并且通过grant_type这个字段来区分模式，并且一定带有clientId和clientSecret</a></p>
<ul>
<li>自定义手机验证码模式（这个可以忽略，需要搞redis,是作者自定义的，不嫌麻烦也可以试下）</li>
<li>简化模式</li>
<li>刷token模式</li>
</ul>
<h4 id="从接口开始走一遍各个模式的流程"><a href="#从接口开始走一遍各个模式的流程" class="headerlink" title="从接口开始走一遍各个模式的流程"></a>从接口开始走一遍各个模式的流程</h4><blockquote>
<p>因为上面我们发现oauth2.0的四种模式，其实就对应着两个地址/token和/authorize.因此接下来，我们就过一下着两个url对应的入口TokenEndpoint和AuthorizationEndpoint</p>
</blockquote>
<h5 id="AuthorizationEndpoint"><a href="#AuthorizationEndpoint" class="headerlink" title="AuthorizationEndpoint"></a>AuthorizationEndpoint</h5><p>对应认证码模式和纯前端的简化模式，具体实现类为org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint</p>
<p>总体入口在122行的authorize方法这里，下面我会把没用的代码都删掉，通过注释带大家看一遍这个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/oauth/authorize&quot;)</span><br><span class="line">	public ModelAndView authorize(Map&lt;String, Object&gt; model, @RequestParam Map&lt;String, String&gt; parameters,</span><br><span class="line">			SessionStatus sessionStatus, Principal principal) &#123;</span><br><span class="line">		</span><br><span class="line">		//通过工厂类将参数包裹为authorizationRequest</span><br><span class="line">		AuthorizationRequest authorizationRequest = getOAuth2RequestFactory().createAuthorizationRequest(parameters);</span><br><span class="line"></span><br><span class="line">        //校验该方法中的response_type参数</span><br><span class="line">		Set&lt;String&gt; responseTypes = authorizationRequest.getResponseTypes();</span><br><span class="line">		if (!responseTypes.contains(&quot;token&quot;) &amp;&amp; !responseTypes.contains(&quot;code&quot;)) &#123;</span><br><span class="line">			throw new UnsupportedResponseTypeException(&quot;Unsupported response types: &quot; + responseTypes);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        //校验是否提供clientId</span><br><span class="line">		if (authorizationRequest.getClientId() == null) &#123;</span><br><span class="line">			throw new InvalidClientException(&quot;A client id must be provided&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">            这里非常重要！！！假如这里你没有登录，这里会直接抛出AuthenticationException,</span><br><span class="line">            而这个异常会被过滤器链filterChain上的spring security 专用的异常处理过滤器捕捉，</span><br><span class="line">            对应的是org.springframework.security.web.access.ExceptionTranslationFilter的105行</span><br><span class="line">            的handleSpringSecurityException这个方法,捕捉后根据不同的实现类</span><br><span class="line">            spring会执行不同的操作，对应于认证码模式，它就会重定向走</span><br><span class="line">            </span><br><span class="line">            因此假如你的项目有全局异常处理器，这里一定要记得不要去捕捉所有异常，如果</span><br><span class="line">            把spring security的异常捕捉了，就会产生意料外的缺陷</span><br><span class="line">            **/</span><br><span class="line">			if (!(principal instanceof Authentication) || !((Authentication) principal).isAuthenticated()) &#123;</span><br><span class="line">				throw new InsufficientAuthenticationException(</span><br><span class="line">						&quot;User must be authenticated with Spring Security before authorization can be completed.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            //这里通过用户传来的clientId去后端查这个客户端的信息，至于具体是去哪里查，</span><br><span class="line">            //依赖于用户具体的service实现方式是jdbc还是redis</span><br><span class="line">			ClientDetails client = getClientDetailsService().loadClientByClientId(authorizationRequest.getClientId());</span><br><span class="line"></span><br><span class="line">			//解析并判断redirect_uri中指定的参数是否与后端配置的一样</span><br><span class="line">			String redirectUriParameter = authorizationRequest.getRequestParameters().get(OAuth2Utils.REDIRECT_URI);</span><br><span class="line">			String resolvedRedirect = redirectResolver.resolveRedirect(redirectUriParameter, client);</span><br><span class="line">			if (!StringUtils.hasText(resolvedRedirect)) &#123;</span><br><span class="line">				throw new RedirectMismatchException(</span><br><span class="line">						&quot;A redirectUri must be either supplied or preconfigured in the ClientDetails&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			authorizationRequest.setRedirectUri(resolvedRedirect);</span><br><span class="line"></span><br><span class="line">			//检查scope参数是否与后端配置的一样</span><br><span class="line">			oauth2RequestValidator.validateScope(authorizationRequest, client);</span><br><span class="line"></span><br><span class="line">		    //这里是用来判断当你采用认证码模式时，跳转过去后，是否需要自动批准第三方客户端使用你的某些信息</span><br><span class="line">			authorizationRequest = userApprovalHandler.checkForPreApproval(authorizationRequest,</span><br><span class="line">					(Authentication) principal);</span><br><span class="line">			boolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);</span><br><span class="line">			authorizationRequest.setApproved(approved);</span><br><span class="line"></span><br><span class="line">			//假如你点了批准或者设置为默认批准</span><br><span class="line">			if (authorizationRequest.isApproved()) &#123;</span><br><span class="line">			    //如果你的response_type是token,则这里直接返回token给前端</span><br><span class="line">				if (responseTypes.contains(&quot;token&quot;)) &#123;</span><br><span class="line">					return getImplicitGrantResponse(authorizationRequest);</span><br><span class="line">				&#125;</span><br><span class="line">				//response_type为code，这里生成code后，return一个重定向的modelAndView完成跳转</span><br><span class="line">				if (responseTypes.contains(&quot;code&quot;)) &#123;</span><br><span class="line">					return new ModelAndView(getAuthorizationCodeResponse(authorizationRequest,</span><br><span class="line">							(Authentication) principal));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Store authorizationRequest AND an immutable Map of authorizationRequest in session</span><br><span class="line">			// which will be used to validate against in approveOrDeny()</span><br><span class="line">			model.put(AUTHORIZATION_REQUEST_ATTR_NAME, authorizationRequest);</span><br><span class="line">			model.put(ORIGINAL_AUTHORIZATION_REQUEST_ATTR_NAME, unmodifiableMap(authorizationRequest));</span><br><span class="line"></span><br><span class="line">			return getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException e) &#123;</span><br><span class="line">			sessionStatus.setComplete();</span><br><span class="line">			throw e;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结一下，这个方法对登录和未登录的访问会进行以下两种处理流程: </p>
<ul>
<li>假如你是未登录来访问这个接口，那么会抛出异常，被ExceptionTranslationFilter捕获，调用handleSpringSecurityException方法，进入sendStartAuthentication方法，假如你配置的是重定向地址，他这里应该就会找到这个LoginUrlAuthenticationEntryPoint，给个重定向到登录页，让你登录。</li>
<li>当你登录server之后，再进这里就是已登录状态了，就直接过去了，然后给你生成code重定向走</li>
</ul>
<h5 id="TokenEndpoint"><a href="#TokenEndpoint" class="headerlink" title="TokenEndpoint"></a>TokenEndpoint</h5><p>对应密码模式和纯后端的client_credentials模式以及拿着code请求token的认证码模式的第二步，具体实现类为org.springframework.security.oauth2.provider.endpoint.TokenEndpoint</p>
<p>总体入口在87行的postAccessToken方法这里，下面我会把没用的代码都删掉，通过注释带大家看一遍这个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/oauth/token&quot;, method=RequestMethod.POST)</span><br><span class="line">	public ResponseEntity&lt;OAuth2AccessToken&gt; postAccessToken(Principal principal, @RequestParam</span><br><span class="line">	Map&lt;String, String&gt; parameters) throws HttpRequestMethodNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        //在到达这个入口之前，UsernamePasswordAuthenticationFilter会</span><br><span class="line">        //把Authorization头中的clientId和clientSecret取出来，放到principal中。</span><br><span class="line">		//因此下面这段主要是对clientId和clientSecret进行校验</span><br><span class="line">		if (!(principal instanceof Authentication)) &#123;</span><br><span class="line">			throw new InsufficientAuthenticationException(</span><br><span class="line">					&quot;There is no client authentication. Try adding an appropriate authentication filter.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		String clientId = getClientId(principal);</span><br><span class="line">		ClientDetails authenticatedClient = getClientDetailsService().loadClientByClientId(clientId);</span><br><span class="line"></span><br><span class="line">		TokenRequest tokenRequest = getOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient);</span><br><span class="line"></span><br><span class="line">		if (clientId != null &amp;&amp; !clientId.equals(&quot;&quot;)) &#123;</span><br><span class="line">			// Only validate the client details if a client authenticated during this</span><br><span class="line">			// request.</span><br><span class="line">			if (!clientId.equals(tokenRequest.getClientId())) &#123;</span><br><span class="line">				//如果不相等或者没找到，则直接抛出异常</span><br><span class="line">				throw new InvalidClientException(&quot;Given client ID does not match authenticated client&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//校验scope是否匹配</span><br><span class="line">		if (authenticatedClient != null) &#123;</span><br><span class="line">			oAuth2RequestValidator.validateScope(tokenRequest, authenticatedClient);</span><br><span class="line">		&#125;</span><br><span class="line">		//下面都是校验各种参数</span><br><span class="line">		if (!StringUtils.hasText(tokenRequest.getGrantType())) &#123;</span><br><span class="line">			throw new InvalidRequestException(&quot;Missing grant type&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (tokenRequest.getGrantType().equals(&quot;implicit&quot;)) &#123;</span><br><span class="line">			throw new InvalidGrantException(&quot;Implicit grant type not supported from token endpoint&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (isAuthCodeRequest(parameters)) &#123;</span><br><span class="line">			// The scope was requested or determined during the authorization step</span><br><span class="line">			if (!tokenRequest.getScope().isEmpty()) &#123;</span><br><span class="line">				logger.debug(&quot;Clearing scope of incoming token request&quot;);</span><br><span class="line">				tokenRequest.setScope(Collections.&lt;String&gt; emptySet());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (isRefreshTokenRequest(parameters)) &#123;</span><br><span class="line">			// A refresh token has its own default scopes, so we should ignore any added by the factory here.</span><br><span class="line">			tokenRequest.setScope(OAuth2Utils.parseParameterList(parameters.get(OAuth2Utils.SCOPE)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        //到这里就来到了整个token方法的核心，这一步会生成token，这里spring security设计的很好</span><br><span class="line">        //灵活性非常高，通过grantType为每个模式指定不同的TokenGranter，将生成token的操作</span><br><span class="line">        //委托给子类</span><br><span class="line">		OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br><span class="line">		if (token == null) &#123;</span><br><span class="line">			throw new UnsupportedGrantTypeException(&quot;Unsupported grant type: &quot; + tokenRequest.getGrantType());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return getResponse(token);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下,token模式，假如你未登录来访问这个接口，也会抛出异常。这个接口的登录是通过配置认证头来实现的，username配置clientId,password配置clientSecret.然后在UsernamePassword*Filter中捕获并注入principal。</p>
<p>这里如果登录无误，就会进入到最重要的方法里，132行的grant中,然后进行生成token操作</p>
<h4 id="然后看一下重要的组件"><a href="#然后看一下重要的组件" class="headerlink" title="然后看一下重要的组件"></a>然后看一下重要的组件</h4><blockquote>
<p>上一章看完了，那么核心问题转化为了，spring security是怎么生成token的。而生成token的核心方法对应于org.springframework.security.oauth2.provider.TokenGranter这个接口的grant方法.接下来让我们看下这个方法，同时再去了解下spring security的核心组件吧。</p>
</blockquote>
<h5 id="TokenGranter"><a href="#TokenGranter" class="headerlink" title="TokenGranter"></a>TokenGranter</h5><blockquote>
<p>话不多说，直接看代码</p>
</blockquote>
<p>首先看一下继承关系:<br><img src="/images/20200902_7.png" alt="7"><br>在上面的token模式中，grant方法默认会进入到AbstractTokenGranter的grant方法中，而假如我们需要自定义认证模式，一般做法也是去继承这个抽象的父类，比如MobileCodeTokenGranter</p>
<p>因此直接看下这个自定义的MobileCodeTokenGranter的代码吧:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义grant_type模式-手机号短信验证模式</span><br><span class="line"> * @author: yaohw</span><br><span class="line"> * @create: 2019-09-29 18:29</span><br><span class="line"> **/</span><br><span class="line">public class MobileCodeTokenGranter extends AbstractTokenGranter &#123;</span><br><span class="line"></span><br><span class="line">    //根据你grant_type参数的不同，这里最后会进入到不同的tokenGranter</span><br><span class="line">    //因此如果需要自定义认证模式，一定要修改这个参数</span><br><span class="line">    private static final String GRANT_TYPE = &quot;mobile&quot;;</span><br><span class="line"></span><br><span class="line">    private final AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    public MobileCodeTokenGranter(AuthenticationManager authenticationManager,</span><br><span class="line">                                  AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory) &#123;</span><br><span class="line">        this(authenticationManager, tokenServices, clientDetailsService, requestFactory, GRANT_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) &#123;</span><br><span class="line">    </span><br><span class="line">        //将参数组装为MobileCodeAuthenticationToken</span><br><span class="line">        Map&lt;String, String&gt; parameters = new LinkedHashMap&lt;String, String&gt;(tokenRequest.getRequestParameters());</span><br><span class="line">        String mobile = parameters.get(&quot;mobile&quot;);</span><br><span class="line">        String code = parameters.get(&quot;code&quot;);</span><br><span class="line"></span><br><span class="line">        Authentication userAuth = new MobileCodeAuthenticationToken(mobile,code);</span><br><span class="line">        ((AbstractAuthenticationToken) userAuth).setDetails(parameters);</span><br><span class="line">        try &#123;</span><br><span class="line">            //最后将这个MobileCodeAuthenticationToken交给authenticationManager来认证</span><br><span class="line">            userAuth = authenticationManager.authenticate(userAuth);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此认证的核心方法最后交给了AuthenticationManager这个类，而这个类又是通过与其他的组件交互，最后完成认证的:</p>
<blockquote>
<p>下面的内容建议直接看该博客:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b87ec108405">https://www.jianshu.com/p/7b87ec108405</a><br><img src="/images/20200902_8.png" alt="8"></p>
</blockquote>
<p>简单的说就是，spring security通过不同的grantType,将颁发token的操作委托给了TokenGranter。</p>
<p>而TokenGranter通过将不同的登录参数组装为不同的token，然后将token委托给AuthenticationMnager来处理。</p>
<p>AuthenticationManager根据不同的token类型，通过调用AuthenticationProvider接口的support方法来决定，将这个token委托给哪个provider处理，最后的主要校验逻辑都是由provider来实现的。</p>
<h4 id="spring-security-oauth-认证服务器"><a href="#spring-security-oauth-认证服务器" class="headerlink" title="spring security oauth 认证服务器"></a>spring security oauth 认证服务器</h4><blockquote>
<p>说到底oauth-server其实就是在spring-security的基础上增加了两个入口和一系列过滤器还有上面这些认证组件，两个入口和这些认证组件上面已经分析过了。剩下的核心其实还是spring-security，通过这一系列的过滤器，spring 完成了一系列鉴权与跳转操作，同时为我们预留了很多接口，方便我们自定义</p>
</blockquote>
<p>spring security 本身并不复杂，它的核心原理可以用这张图和三局话概括:</p>
<ul>
<li>整个框架的核心是一个过滤器，这个过滤器名字叫springSecurityFilterChain类型是FilterChainProxy</li>
<li>核心过滤器里面是过滤器链（列表），过滤器链的每个元素都是一组URL对应一组过滤器</li>
<li>WebSecurity用来创建FilterChainProxy过滤器，HttpSecurity用来创建过滤器链的每个元素。</li>
</ul>
<p><img src="/images/20200902_9.png" alt="9"></p>
<p>如果想仔细了解，推荐这个博客，上面三句话也是来自这个博客的: <a target="_blank" rel="noopener" href="https://blog.csdn.net/zimou5581/article/details/102457672">https://blog.csdn.net/zimou5581/article/details/102457672</a></p>
<p>另外spring security提供了非常多的过滤器，如果想要了解的话，可以看这个博客:<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1551517">https://cloud.tencent.com/developer/article/1551517</a></p>
<h4 id="内网的auth-server-和-client-的项目结构和改造思路，以及如何配置使用"><a href="#内网的auth-server-和-client-的项目结构和改造思路，以及如何配置使用" class="headerlink" title="内网的auth-server 和 client 的项目结构和改造思路，以及如何配置使用"></a>内网的auth-server 和 client 的项目结构和改造思路，以及如何配置使用</h4><p>参见内网文档 以及 代码注释</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/09/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E4%B9%8Bspring-security-oauth%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="ckt1qkaw0000a0cvr4pbrdr7w" data-title="微服务认证方案设计之spring-security-oauth（二）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="backend-信息系统中的统一身份认证与授权（一）" class="h-entry article article-type-backend" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/01/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-09-01T15:59:11.000Z" itemprop="datePublished">2021-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/01/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/">信息系统中的统一身份认证与授权（一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文主要为整个项目中的信息系统认证架构的发展与介绍，并同时给大家科普一些基础的知识点，不涉及比较深奥的技术</p>
</blockquote>
<p>主要讲解知识点:</p>
<ul>
<li>认证、授权、鉴权和权限控制</li>
<li>有状态与无状态</li>
<li>CAS单点登录协议</li>
<li>Oauth2.0协议</li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="1-认证、授权、鉴权和权限控制"><a href="#1-认证、授权、鉴权和权限控制" class="headerlink" title="1.认证、授权、鉴权和权限控制"></a>1.认证、授权、鉴权和权限控制</h3><blockquote>
<p>本章节主要内容参考的博客链接为: <a target="_blank" rel="noopener" href="http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/">http://www.hyhblog.cn/2018/04/25/user_login_auth_terms/</a> </p>
</blockquote>
<p>下面将简要的介绍一下信息安全领域中认证、授权、鉴权和权限控制这四个概念，并对他们之间的关系进行简要的梳理。对于现在的信息系统而言，都是由多个网站和应用组成的，如下图所示:</p>
<p><img src="/images/20200902_1.PNG" alt="1"></p>
<p>而在一次简单的登录流程中，我们要按顺序完成以下四个步骤: 认证、授权、鉴权和权限控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">用户-&gt;&gt;官网: 想看大数据的页面</span><br><span class="line">官网-&gt;&gt;用户: 你是谁?麻烦先登录</span><br><span class="line">用户-&gt;&gt;认证中心: 输入用户名密码来登录 (认证)</span><br><span class="line">认证中心-&gt;&gt;用户: 给你一个令牌 (授权)</span><br><span class="line">用户-&gt;&gt;官网: 带着令牌过来访问大数据页面</span><br><span class="line">官网-&gt;&gt;认证中心:校验令牌是真是假 (鉴权)</span><br><span class="line">认证中心-&gt;&gt;官网:令牌为真</span><br><span class="line">官网-&gt;&gt;认证中心: 这个令牌有没有访问这个页面的权限 (权限控制)</span><br><span class="line">认证中心-&gt;&gt;官网: 有权限</span><br><span class="line">官网-&gt;&gt;用户: 允许访问，返回界面</span><br></pre></td></tr></table></figure>
<p>接下来将依次对这四个概念进行介绍:</p>
<h4 id="1-1认证"><a href="#1-1认证" class="headerlink" title="1.1认证"></a>1.1认证</h4><p>认证是指根据声明者(用户)所特有的识别信息，确认声明者的身份。认证在英文中对应于identification这个单词。</p>
<p>最常见的认证实现方式是通过用户名和密码，但认证方式不限于此。下面都是当前常见到的认证技术，</p>
<ul>
<li>身份证</li>
<li>用户名和密码</li>
<li>用户手机：手机短信、手机二维码扫描、手势密码</li>
<li>用户的电子邮箱</li>
<li>基于时间序列和用户相关的一次性口令</li>
<li>用户的生物学特征：指纹、语音、眼睛虹膜</li>
<li>用户的大数据识别…</li>
</ul>
<blockquote>
<p>现在认证中心知道这个使用者是用户A了，但是它应该怎么告诉官网呢?</p>
</blockquote>
<h4 id="1-2授权"><a href="#1-2授权" class="headerlink" title="1.2授权"></a>1.2授权</h4><p>简单来说，授权一般是指获取用户的委派权限。在英文中对应于authorization这个单词。</p>
<p>在信息安全领域，授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作。这里面包含有如下四个重要概念</p>
<blockquote>
<p>换句人话来说，就是认证中心(资源所有者)颁发一个令牌(包含权限)给用户A正在使用的浏览器(执行者)，让这个浏览器(执行者)可以去官网拿数据（对资源执行读取操作）。这个颁发令牌的过程就是授权的一种实现方式。</p>
</blockquote>
<p>授权的实现方式非常多也很广泛，我们常见的银行卡、门禁卡、钥匙、公证书，这些都是现实生活中授权的实现方式。其实现方式主要通过一个共信的媒介完成，这个媒介不可被篡改。</p>
<p>在互联网应用开发领域，授权所用到的授信媒介主要包括如下几种，</p>
<ul>
<li>通过web服务器的session机制，一个访问会话保持着用户的授权信息</li>
<li>通过web浏览器的cookie机制，一个网站的cookie保持着用户的授权信息</li>
<li>颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息<br>前面两者常见于web开发，需要有浏览器的支持。</li>
</ul>
<h4 id="1-3鉴权"><a href="#1-3鉴权" class="headerlink" title="1.3鉴权"></a>1.3鉴权</h4><p>一句话概括， 鉴定你上一步颁发的令牌的真实性和有效性</p>
<h4 id="1-4权限控制"><a href="#1-4权限控制" class="headerlink" title="1.4权限控制"></a>1.4权限控制</h4><p>一句话概括，令牌虽然是真的，但还判断你的令牌有没有权限访问这个接口</p>
<h3 id="2-有状态与无状态"><a href="#2-有状态与无状态" class="headerlink" title="2.有状态与无状态"></a>2.有状态与无状态</h3><blockquote>
<p>本章节推荐阅读以下博客: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/shiyajian/p/10672908.html">https://www.cnblogs.com/shiyajian/p/10672908.html</a></p>
</blockquote>
<p>上一章节这四点，是一个系统的基石。因此接下来所有的认证权限技术方案都是围绕上面四点来设计的,而目前实现统一身份认证和授权的技术手段较多，总体可以归纳为以下两类：</p>
<ul>
<li>传统的 Cookie + Session 解决方案，有状态会话模式</li>
<li>基于令牌/票据token的解决方案，无状态交互模式</li>
</ul>
<p>Cookie/session本质上也是一种令牌token，但cookie/session相对于令牌最大的区别的是，服务器端会为每个不同的cookie/session在服务器端保存这个用户对应的信息,服务器拿到session后，会从服务器上取出；而无状态token的用户信息是直接放在token里面的，服务器拿到token后，通过约定的解密方式，将这个token解析出来，来获取这个用户是谁。因此有状态与无状态两种模式最大的区别就在于服务端会不会保存客户端的信息。</p>
<blockquote>
<p>这两种模式互有优缺点，不存在哪种技术方案更好的说法。只有最适合的技术，没有最好的技术</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>无状态</th>
<th>有状态</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>节省服务器资源，方便水平扩展，适合集群服务器，适合绝大部分设备</td>
<td>服务器可以方便地操控用户的登录状态(踢出，拉黑)</td>
</tr>
<tr>
<td>缺点</td>
<td>服务器端难以操控用户的登录状态(踢出登录…)</td>
<td>对服务器资源占用较多，部分设备不支持cookie/session，集群服务器中共享session不方便</td>
</tr>
</tbody></table>
<p>目前比较流行的就是互联网APP中大部分采用 JWT 的认证方式，一些企业内部管理系统则大部分采用 cookie-session 的机制，原因可能如下：</p>
<p>1、在互联网APP产品中，尤其以 to C 模式，用户量极大，为了用户体验，一般会将登录信息保留特别长时间，某些APP 只要你不卸载，那么不管几个月之后登录，账户还是处于登录状态。在这种情况下，假如采用 cookie-session 机制，那么你的用户信息保存很多个月，用户量特别大的情况下，会造成大量资源占用和浪费，这种场景采用 JWT 就是相对比较好的方案。</p>
<p>2、企业内部管理系统有以下特点：用户量较少（最多最多不超过10W人），信息安全要求高（及时踢出客户端登录状态，个人浏览器关闭账号退出登录），在这样的场景下占用的内存不会太多，所以基于 cookie-session 这种机制，是比较好的方案，如果企业内部还有其他应用需要集成时候，需要使用 SSO Server 实现。</p>
<h2 id="认证系统的方案发展"><a href="#认证系统的方案发展" class="headerlink" title="认证系统的方案发展"></a>认证系统的方案发展</h2><h3 id="2-基于cookie-session机制的cas-shiro方案"><a href="#2-基于cookie-session机制的cas-shiro方案" class="headerlink" title="2.基于cookie/session机制的cas + shiro方案"></a>2.基于cookie/session机制的cas + shiro方案</h3><blockquote>
<p>项目组成立之初，系统的整体架构还是单体应用的设计方案，因此我们直接沿用了之前项目的登录方案，认证框架采用cas，授权模式为有状态的cookie/session方案，鉴权与权限控制框架为shiro</p>
</blockquote>
<blockquote>
<p>单点登录的原理可以参考这篇博客: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/ywlaker/p/6113927.html">https://www.cnblogs.com/ywlaker/p/6113927.html</a></p>
</blockquote>
<blockquote>
<p>CAS的开发可以参考这个博客: <a target="_blank" rel="noopener" href="https://blog.csdn.net/u010475041/article/details/77886765">https://blog.csdn.net/u010475041/article/details/77886765</a></p>
</blockquote>
<p>而我们这套框架的核心就是CAS，接下来用一句话介绍CAS:<br>CAS （ Central Authentication Service ） 是 Yale 大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方法。</p>
<p>CAS 单点登录的整体流程可以通过以下一张图来描述清楚:<br><img src="/images/20200902_2.PNG" alt="2"></p>
<p>CAS为认证专门设计了几种令牌票据，ST TGC TGT，只要理解了这些票据，整个CAS就不难理解了:</p>
<ul>
<li>TGT</li>
</ul>
<p>TGT 是CAS-server  为用户签发的登录 ticket，也是用于验证用户登录成功的唯一方式。 TGT 封装了 Cookie 值以及 Cookie 值对应的用户信息，CAS 通过 Cookie 值（TGC）为 key 查询缓存中有无 TGT（TGC:TGT（key:value）），如果有的话就说明用户已经登录了cas-server，无须重复登录。</p>
<ul>
<li>TGC  </li>
</ul>
<p>CAS-server 会将生成的 TGT 放在 session 中，而 TGC 就是这个 session 的唯一标识(sessionId)，可以认为是 TGT 的key，为 TGT 就是 TGC 的 value，TGC 以 cookie 的形式保存在浏览器中，每个请求都会尝试携带 TGC。（每个服务都会在 session 和 cookie 中保存对应的 TGT 和 TGC）</p>
<ul>
<li>ST</li>
</ul>
<p>ST 是当用户访问某一服务时提供的 ticket。用户在访问其他服务时，发现没有 cookie 或 ST ，那么就会重定向到 CAS 服务器获取 ST。然后会携带着 ST 重定向 回来。</p>
<hr>
<p>因此，我们可以发现，作为一个PC端的单点登录框架，CAS是完美的满足了我们的需求，并且提供了较高的安全性。但是随着移动端和宏天接入了我们的系统，并且我们准备采用微服务架构后，就没那么完美了，因为原来的这套架构会带来以下几个无法避免的问题:</p>
<ul>
<li>移动端使用cookie/session很不方便</li>
<li>宏天是无状态的微服务架构，采用的是jwt token来认证，与我们现有的有状态cookie/session互不兼容</li>
<li>微服务架构下使用session很不方便,虽然分布式 Session 可以解决这个问题，但因其状态化通信的特性与微服务提倡的API导向无状态通信相互违背，且共享式存储存在安全隐患，因此微服务一般不太采用</li>
</ul>
<blockquote>
<p>其实新版本的cas也是支持无状态token和oauth2.0协议的，只是我们之前使用的cas是4.3版本的，太老了</p>
</blockquote>
<h3 id="3-基于无状态token的oauth2-0-jwt-spring-security方案"><a href="#3-基于无状态token的oauth2-0-jwt-spring-security方案" class="headerlink" title="3.基于无状态token的oauth2.0+jwt+spring-security方案"></a>3.基于无状态token的oauth2.0+jwt+spring-security方案</h3><blockquote>
<p>因此基于以上几个原因，我们将整个项目组的登录架构升级为了以下方案: 认证协议采用oauth2.0，授权模式为无状态的票据token方案，鉴权与权限控制框架为spring-security</p>
</blockquote>
<blockquote>
<p>oauth2.0推荐参考以下链接: <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a> 和 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a> 和 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">OAuth 2.0 的四种方式</a></p>
</blockquote>
<p>而我们这套框架的核心协议就是Oauth2.0协议，一句话介绍它:<br>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p>
<p>Oauth2.0的核心就只是向第三方应用颁发令牌，但由于现在的互联网有多种场景，因此它为这些场景规定了四种统一的标准流程。 分别是:</p>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）</li>
<li>客户端凭证（client credentials）</li>
</ul>
<p>因此理解oauth2.0的前提就是理解这四种流程，我在开发这套框架的时候就发生了因为理解有误，导致采用错了流程，最后走了弯路的情况。</p>
<h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p>
<p>这种方式是最常用的流程，大家日常生活中肯定用过，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>下为具体例子,假如我要登录gitee网站，但是没有账号又不想注册: </p>
<ul>
<li>第一步, gitee 网站提供一个链接，用户点击后就会跳转到微信登录页面，授权用户数据给gitee网站使用</li>
</ul>
<p><img src="/images/20200902_3.PNG" alt="3"></p>
<p><img src="/images/20200902_4.PNG" alt="4"></p>
<p>下面就是gitee网站跳转微信的一个示意链接:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/qrconnect?</span><br><span class="line">appid=wx63d402790645b7e6&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fgitee.com%2Fauth%2Fwechat%2Fcallback&amp;</span><br><span class="line">response_type=code&amp;</span><br><span class="line">scope=snsapi_login</span><br><span class="line">&amp;state=9d90ceb6b3ad0a633a0085541ad024d18bcc96004b20c2a5#wechat_redirect</span><br></pre></td></tr></table></figure>
<p>而标准的oauth2.0跳转链接为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>

<p>上面 URL 中，response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。</p>
<ul>
<li>第二步，用户跳转后，微信会要求用户登录，然后询问用户是否同意给予 gitee 网站授权。</li>
</ul>
<p><img src="/images/20200902_5.jpg" alt="5"></p>
<p>用户表示同意，这时 微信 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/callback?code=AUTHORIZATION_CODE</span><br></pre></td></tr></table></figure>
<p>上面 URL 中，code参数就是授权码。</p>
<ul>
<li>第三步，gitee网站拿到授权码以后，就可以在后端，向微信请求令牌。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure>
<p>上面 URL 中，client_id参数和client_secret参数用来让 B确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求），grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code参数是上一步拿到的授权码，redirect_uri参数是令牌颁发后的回调网址。</p>
<ul>
<li>第四步，微信收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;bearer&quot;,</span><br><span class="line">  &quot;expires_in&quot;:2592000,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">  &quot;scope&quot;:&quot;read&quot;,</span><br><span class="line">  &quot;uid&quot;:100101,</span><br><span class="line">  &quot;info&quot;:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候gitee的后端就可以拿着这个access_token来访问微信的接口，获取你的信息。整个授权码模式就结束了</p>
<blockquote>
<p>通常情况下，第三方应用还会弹出以下界面来让你将微信的个人信息绑定到它的系统中的账号里，这块并不属于oauth2.0的标准流程，是应用自己添加的,这时候第三方应用其实已经拿到了你的微信账号信息。如下图所示:<br><img src="/images/20200902_6.png" alt="6"></p>
</blockquote>
<p>==通过上面的流程，我们不难发现授权码模式主要适用于第三方应用接入你的系统的模式，它的安全性也是非常搞的，敏感信息都是通过后端来调用的，对前端可见的都是不敏感的或者快速失效的信息，并且对于权限粒度的控制也是很好的，就像gitee刚刚申请的那个令牌，就只能获取我的账号信息而已，那个token是没有权限访问其他的信息的==</p>
<h4 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a>密码式</h4><p>如果你高度信任某个应用，用户也可以把用户名和密码，直接告诉该应用。该应用就使用你的密码，调用接口申请令牌，这种方式称为”密码式”（password）。</p>
<p>==这种模式只适用于自己系统内的应用，比如我们现在信息系统内的所有应用 pubs, bms, 移动端都是使用这种模式来获取令牌的。绝对不能给第三方应用使用这种模式==</p>
<h4 id="凭证式和隐藏式"><a href="#凭证式和隐藏式" class="headerlink" title="凭证式和隐藏式"></a>凭证式和隐藏式</h4><p>这两种模式其实是很相似的。</p>
<p>隐藏式适合那些纯前端的应用，它们没有后端，必须将令牌储存在前端，因此只能直接将令牌颁发给前端，这种模式是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>

<p>凭证式适用于没有前端的纯后端应用，也就是后端直接向认证中心申请令牌，而这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure>

<hr>
<p>==注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的==</p>
<hr>
<p>授权码模式是oauth2.0四种模式中使用最为广泛也是最安全最复杂的一种，其他三种模式相对来说都偏少一些，只要我们理解了上面四种模式，然后知道它们分别适用于哪些场景，那么oauth2.0对大家来说也就没什么难处的了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次分享中主要讲解了以下概念:</p>
<ul>
<li>认证、授权、鉴权和权限控制</li>
<li>有状态与无状态</li>
<li>CAS单点登录协议</li>
<li>Oauth2.0协议</li>
</ul>
<p>当然认证与授权并不只有这些概念，还有cookie/session的实现原理，无状态令牌的实现方式(jwt)，以及鉴权框架shiro，spring-security的区别等等这些更为具体的开发知识。但是了解上述的这些概念，已经能对整个系统的架构设计与方案有一个大体的了解了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/09/01/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/" data-id="ckt1qkavy00090cvrg26qgfe9" data-title="信息系统中的统一身份认证与授权（一）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="work-工作准备" class="h-entry article article-type-work" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/%E5%B7%A5%E4%BD%9C%E5%87%86%E5%A4%87/" class="article-date">
  <time class="dt-published" datetime="2021-08-17T05:00:49.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/%E5%B7%A5%E4%BD%9C%E5%87%86%E5%A4%87/">工作准备</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="职位方向"><a href="#职位方向" class="headerlink" title="职位方向"></a>职位方向</h2><p>毕业两年主要做的是java后端，前后一共四个项目，交易所官网，信息披露国际化demo， 信息披露国际化， 科交所。涉及的行业主要是金融，国际化。项目的技术侧重点主要是java后端，高可用，工作流。除了工作流，其他的我都算是比较了解，也算是比较了解。技术的宽度还算不错。</p>
<p>因此整体找工作的方向应该是偏向金融，国际化项目(英语)，高可用/docker/底层高可用/基础架构，用户体系单点登录， 工作流方向。复习的优先级为优先拓展当前技能的深度，同时发挥自己以上项目经验的优势，拓宽各个方向的深度。</p>
<h2 id="后端常见要求"><a href="#后端常见要求" class="headerlink" title="后端常见要求"></a>后端常见要求</h2><p>看了一下常见的后端岗位，基本要求摘要如下：</p>
<ol>
<li>Java基础扎实，理解io、多线程、集合等基础框架，对JVM原理有一定的了解；熟悉面向对象设计开发;熟悉单元测试代码的编写；</li>
<li>熟悉linux操作系统，对各种开源框架如Spring、MyBatis，Memcache、Redis、消息队列等有深入的了解；对缓存、消息队列、异步任务、负载均衡、分库分表等后端技术有充分了解和实践</li>
<li>熟悉数据库原理和技术，熟练掌握 MySQL、MongoDB数据库，精通关系型数据库及SQL优化</li>
<li>熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息、搜索\推荐等机制；能对分布式常用技术进行合理应用，解决问题；有大型分布式、高负载、高可用性系统设计和稳定性经验优先；熟悉分布式系统原理和设计，熟悉Redis 、Activemq 、Zookeeper等开源项目，能合理进行技术选型，善于解决问题；熟悉互联网应用架构，在高可用系统设计，开发和调优方面有实际经验；</li>
<li>具有高并发大数据量系统的开发和维护经验，高业务复杂度相关系统的架构设计；有高并发服务设计和实现经验优先；；对大数据技术，如Spark、Hadoop、Flink、ELK等有使用经验者优先；</li>
<li>我们希望你对互联网或J2EE应用开发的最新潮流有关注，喜欢去看及尝试最新的技术，追求编写优雅的代码，从技术趋势和思路上能影响技术团队；喜欢钻研新技术，热衷于分享。</li>
</ol>
<p>总结提炼一下分为：</p>
<ul>
<li>语言基础</li>
<li>框架原理</li>
<li>中间件原理</li>
<li>数据库原理</li>
<li>分布式</li>
<li>高并发</li>
<li>高可用，负载均衡，架构设计</li>
<li>大数据，区块链，k8s等新技术</li>
</ul>
<p>工作项目经验的侧重点（都有项目经验，可以作为特点深入研究发挥一下）:</p>
<ul>
<li>金融</li>
<li>国际化项目(英语)</li>
<li>高可用/docker/底层高可用/基础架构</li>
<li>用户体系单点登录</li>
<li>工作流方向</li>
</ul>
<h2 id="基础软工复习大纲"><a href="#基础软工复习大纲" class="headerlink" title="基础软工复习大纲"></a>基础软工复习大纲</h2><h3 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1.计算机网络"></a>1.计算机网络</h3><h3 id="2-TCP-IP详解"><a href="#2-TCP-IP详解" class="headerlink" title="2.TCP/IP详解"></a>2.TCP/IP详解</h3><h3 id="3-数据结构与算法"><a href="#3-数据结构与算法" class="headerlink" title="3.数据结构与算法"></a>3.数据结构与算法</h3><h3 id="4-数据库系统概念"><a href="#4-数据库系统概念" class="headerlink" title="4.数据库系统概念"></a>4.数据库系统概念</h3><h3 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5.操作系统"></a>5.操作系统</h3><h3 id="网络及分布式计算"><a href="#网络及分布式计算" class="headerlink" title="网络及分布式计算"></a>网络及分布式计算</h3><h3 id="计算机组织与结构体系"><a href="#计算机组织与结构体系" class="headerlink" title="计算机组织与结构体系"></a>计算机组织与结构体系</h3><h2 id="后端开发基础知识复习大纲"><a href="#后端开发基础知识复习大纲" class="headerlink" title="后端开发基础知识复习大纲"></a>后端开发基础知识复习大纲</h2><ul>
<li>linux</li>
<li>nginx等底层应用</li>
<li>中间件原理</li>
<li>数据库原理</li>
<li>分布式</li>
<li>高并发</li>
<li>高可用，负载均衡，架构设计</li>
</ul>
<h2 id="JAVA领域复习大纲"><a href="#JAVA领域复习大纲" class="headerlink" title="JAVA领域复习大纲"></a>JAVA领域复习大纲</h2><ul>
<li>语言基础</li>
<li>框架原理</li>
</ul>
<h2 id="其他领域学习路线"><a href="#其他领域学习路线" class="headerlink" title="其他领域学习路线"></a>其他领域学习路线</h2><ul>
<li>大数据</li>
<li>区块链</li>
<li>k8s等新技术</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/%E5%B7%A5%E4%BD%9C%E5%87%86%E5%A4%87/" data-id="ckt1qkavw00080cvr550p6qi4" data-title="工作准备" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="diary-二十不惑" class="h-entry article article-type-diary" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/%E4%BA%8C%E5%8D%81%E4%B8%8D%E6%83%91/" class="article-date">
  <time class="dt-published" datetime="2021-08-17T05:00:02.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/%E4%BA%8C%E5%8D%81%E4%B8%8D%E6%83%91/">二十不惑</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<blockquote>
<p>写在2020/7/18日的话</p>
</blockquote>
<p>距离二十四岁生日已经过去了三个月，因为今年想换工作的缘故，对自己的未来也思考了很多，这段时间非常非常的迷茫，好在经过与各个朋友以及亲戚的沟通后，我大概明白了未来的路怎么走，我想要的到底是什么，我能做的又有什么</p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>县城普通家庭出身，从普通的小学到普通的初中最后到普通的高中，初中的我成绩差到我妈妈扬言你只要考上二本，她就很开心了。高中的时候，也不知是怎么地，突然开窍了，压线考入了武汉大学软件工程，然后大学四年也这么普普通通的过来了，一切都是那么的普通。普通的小镇做题家考上了不错的大学，毕业后发现你从哪个阶级来，还是得回哪里去，大学并不能改变什么，除非你本身能力就非常不普通。</p>
<h2 id="关于职业"><a href="#关于职业" class="headerlink" title="关于职业"></a>关于职业</h2><p>毕业后当了一个普通的后端程序员，来到深圳某证券国企。两年后，发现在深圳这个地方，大学毕业的孩子想要留下来，要么卖命要么家里有钱，不然得话一套六百万的房子，首付都要两百万，怎么留的住呢。</p>
<p>假设你三十岁家里和自己一共套的出100万，假设你的另一半家里也能掏出一百万，一共两百万可以凑出深圳一个足够住的还不错的房子的首付，然后三十岁背上了四百万债务。然后妻子结婚生子，而你过了三十薪资开始逐渐平缓甚至下滑，生孩子后消费大大上升，那这种生活真的过得很艰难，虽然强留也是可以留下来的。就看个人选择了，你至少得为这套房子奋斗到中年。然而现实是三十岁夫妻俩大概率拿不出两百万的，你只能买到一个凑合的房子，而这个房子一定是不够住的，然后等房贷还的差不多，你们还得考虑置换房子的问题，然后为了大城市的一套房子，奋斗终生。</p>
<h2 id="关于最近"><a href="#关于最近" class="headerlink" title="关于最近"></a>关于最近</h2><p>毕业两年后，家里和手上也有点积蓄，开始考虑后面的事情了。</p>
<p>最开始我的想法是先把深户迁回武汉，在武汉买套刚需房子，租出去养贷,一步到位，然后再找工作，无论是北上深杭还是哪里，哪里钱多去哪里。如果几年后混的还行，能在大城市待下去，就把武汉的房子卖了，再在那个城市留下来。如果不行，那就回武汉安心工作养老了。</p>
<p>但被我朋友一句话点醒了，你这完全只考虑你自己一个人，你的人脉完全被浪费了，三十回武汉重新开始吗，然后去相亲？或者如果你在另外的城市遇到她了，然后混的一般她不愿意跟你回去怎么办？而且房子作为人生中的第一个大件，第一套买了就不要打算拿来置换或者卖，因为非常非常亏。</p>
<p>但是我自己这么早回武汉又有点怕找不到合适的工作，所以就陷入了僵局。后面跟亲戚和另一个朋友聊天的时候，他们一句话点醒了我，反正你今年都打算换工作，下个工作的时候再考虑买房，对啊？！我悟了</p>
<p>现在我的想法是年底拿完年终奖必走，这半年就不纠结买房和迁户口的事了，认真准备找工作，找到一份薪资勉强能匹配当地房价的工作，换句话说一定是自己能呆得住的城市。</p>
<p>下一份工作在哪儿，我就努力留在那里定居，并将那份工作做好。不再换城市，也不再奔波。因为每次换城市都是对自己积累的人脉的一次浪费，而且年龄也不小了，是该考虑买房了，这个东西总是是要买的。</p>
<h2 id="关于下半年"><a href="#关于下半年" class="headerlink" title="关于下半年"></a>关于下半年</h2><p>下半年给自己定两个目标：</p>
<ul>
<li>优先级最高: 认真准备找工作</li>
<li>根据工作岗位的好坏以及当地城市的房价以及饮食，气候，生活的便利度舒适程度，选择自己将来定居的城市，并不再挪坑了，努力留在当地生活</li>
</ul>
<h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>再后面的事儿就水到渠成，日后再说了</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>我想要的不是三十多岁像狗一样加班，无法陪家人；我想要的是能在还不错的城市，给自己和家人一个快乐幸福的生活，能有一定的经济自由去见朋友，去旅游，去过自己的生活，做自己年轻时候的梦，这就是我对未来的期盼和自己想要的生活的定义。</p>
<p>而这一切的前提是，我不能被无穷无尽的房贷捆绑，如果能力不够，在北上深并不能过一个还不错的比较有品质的生活，那我宁愿退一步，去次一线，给我给我的家庭一个快乐满足的高品质生活，毕竟人生只有一次，我不想留遗憾，不想让我的人生被无穷无尽的压力捆绑摧毁。当然你可以选择留在一线奋斗终身，这是你的自由也是你的权利，追求不同罢了，萝卜白菜各有所爱。</p>
<p>人无远虑必有近忧，人生这条路很漫长，你可以不知道下一步会遇到谁，你可以不知道下一步看到什么风景，但你不能迷茫，不能踌躇不前，</p>
<p>道阻且长,行则将至。不要被焦虑捆绑，做好自己，问自己想要什么，并坚定不移的走下去。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/%E4%BA%8C%E5%8D%81%E4%B8%8D%E6%83%91/" data-id="ckt1qkavv00060cvrcjnb1okm" data-title="二十不惑" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="diary-写在2020年的话" class="h-entry article article-type-diary" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/%E5%86%99%E5%9C%A82020%E5%B9%B4%E7%9A%84%E8%AF%9D/" class="article-date">
  <time class="dt-published" datetime="2021-08-17T04:51:24.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/%E5%86%99%E5%9C%A82020%E5%B9%B4%E7%9A%84%E8%AF%9D/">写在2020年的话</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>不知不觉2020已经过去大半了，我这个拖延症重度患者在拖延了一年多以后，终于也算是用另一种方式完成了个人网站的一部分——博客网站，虽然用的是现有的轮子哈哈哈。刚开始有这个写博客想法的时候，其实是想从零自己造一个博客轮子，但是实在是高估了自己的决心，然后望而却步一拖再拖，而今终于踩在前人的肩膀上算是完成了一个小目标。</p>
</blockquote>
<p><img src="/images/2020%E6%97%A5%E6%9C%AC.jpg" alt="2020"></p>
<h3 id="过往已过"><a href="#过往已过" class="headerlink" title="过往已过"></a>过往已过</h3><p>​        写这篇日记的时候正是20年6月底，从18年7月毕业南下深圳入职以来，一晃已经过去两年了。身为一个入行两年的菜鸟，越发感觉到了自己的不足与微小，中间也曾经一度动摇过，我到底适不适合在这行继续深耕下去，但是想想自己这两年的所作所为，其实并不是天赋不够，而是努力程度低到了都不用拼天赋的可笑地步。虽然也不觉得自己能成为这一行里拔尖的那些人，但觉得如果能拿出当年高考的拼劲儿，能在这行混个不错，吃饱饭还是可以的。<br>​<br>​        我不是一个喜欢总结过去经历的人，过去的就过去了，活在过去很累也没有必要，虽然晚上睡觉之前，那些过往的画面 比如种种不堪 或是快乐时光  偶尔也会如幻灯片一样在眼前略过，但是也只是略过而已。虽然活在过去确实没必要，但总结过往的缺点还是很有必要的。回首过往两年的经历，我觉得自己最大的缺点一个是没有勇气，一个是很怠惰，简单的说其实就是又怂又懒。懒惰贪图安逸的天性在最近轮番被刺激后，改进了很多，目前的成果就是这个博客网站以及这篇博客，希望以后能产出更多高质量的博客，向懒惰的自己说不；怂的话，很难解决了，根源在于没有自信，要解决说难也难，说不难也不难，那就是变得强大（物质，精神）</p>
<h3 id="未来可期"><a href="#未来可期" class="headerlink" title="未来可期"></a>未来可期</h3><p>过往已过，现在是2020/6/28 今年剩下的时间也不多，三个学习上的小目标：</p>
<ul>
<li><p>努力准备争取在今年找到一份心仪的工作</p>
</li>
<li><p>英语提升到听说读写 可以正常沟通与阅读文档的水平</p>
</li>
<li><p>没事学学金融与交易，弄点小钱玩玩金融产品</p>
</li>
</ul>
<blockquote>
<p>(这点就不用担心了，身为一个玩比特币交过不少学费的人，控制仓位止损止盈不频繁交易是基本原则还是知道的哈哈哈哈)</p>
</blockquote>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>​        最近这段时间其实是很忙的，但就我观察而言，工作上的忙碌与频繁加班只不过是因为项目组的管理极其混乱造成的，项目组前期工作的准备不充分，多个领导的干预，需求与产品地位的低下与话语权缺失，导致整个开发组一直在跟着需求的反复地变更进行反复地修改，真是有点醉，很讨厌这种极其频繁的需求变更引起的加班与这种乱七八糟的工作节奏。我得学会从这种节奏中抽出时间来，既然打算要走了，那就得以自己的生活为核心与重点。毕竟握不住的沙，那就扬了它，不太喜欢的工作，那就拜拜了您嘞~</p>
<blockquote>
<p><em>鲤鱼王，你什么时候才能变成暴鲤龙呢</em></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/%E5%86%99%E5%9C%A82020%E5%B9%B4%E7%9A%84%E8%AF%9D/" data-id="ckt1qkavw00070cvreirdaf6a" data-title="写在2020年的话" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="java-javaOverview" class="h-entry article article-type-java" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/javaOverview/" class="article-date">
  <time class="dt-published" datetime="2021-08-16T16:28:09.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/javaOverview/">javaOverview</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/javaOverview/" data-id="ckt1qkavt00030cvr17818xyd" data-title="javaOverview" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="photo-myPhoto" class="h-entry article article-type-photo" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/myPhoto/" class="article-date">
  <time class="dt-published" datetime="2021-08-16T16:27:50.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/myPhoto/">myPhoto</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/myPhoto/" data-id="ckt1qkavu00040cvr98zg7d62" data-title="myPhoto" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="personal-diary2020" class="h-entry article article-type-personal" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/diary2020/" class="article-date">
  <time class="dt-published" datetime="2021-08-16T16:27:28.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/diary2020/">diary2020</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/diary2020/" data-id="ckt1qkavm00000cvr718x1sot" data-title="diary2020" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="personal-diary1" class="h-entry article article-type-personal" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/diary1/" class="article-date">
  <time class="dt-published" datetime="2021-08-16T16:27:23.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/diary1/">diary1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/diary1/" data-id="ckt1qkavr00010cvr89hu0yls" data-title="diary1" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="resume-resume" class="h-entry article article-type-resume" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/17/resume/" class="article-date">
  <time class="dt-published" datetime="2021-08-16T16:25:47.000Z" itemprop="datePublished">2021-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/17/resume/">resume</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
         <center>
     <h1> 雷振 </h1>
 </center>

<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul>
<li>性 别：男&nbsp;&nbsp;&ensp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp; 年 龄：25  </li>
<li>手 机：13006189736 &nbsp;&nbsp;&nbsp;&nbsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;   邮 箱：<a href="mailto:&#x31;&#51;&#x30;&#48;&#54;&#x31;&#x38;&#57;&#x37;&#x33;&#54;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;">&#x31;&#51;&#x30;&#48;&#54;&#x31;&#x38;&#57;&#x37;&#x33;&#54;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;</a>    </li>
<li>专 业：软件工程 &nbsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 岗 位：后台开发工程师</li>
</ul>
<h2 id="工作及教育经历"><a href="#工作及教育经历" class="headerlink" title="工作及教育经历"></a>工作及教育经历</h2><ul>
<li>武汉大学&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;&emsp;&emsp;&emsp;&ensp;&ensp;&ensp;2014.9~2018.7&emsp;&emsp;&emsp;&emsp;&emsp; 计算机学院-软件工程专业-本科       </li>
<li>深圳证券通信有限公司&emsp;&emsp;&emsp;&emsp;&emsp;2018.7~至今&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 交易结算事业部-后台开发工程师         </li>
</ul>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ul>
<li>熟悉计算机网络和操作系统等基础知识，有linux(centos/redhat)维护部署排查问题以及shell脚本经验，通过了红帽RHCE认证;</li>
<li>掌握了Java常见的开发知识，理解多线程、集合等基础框架，对JVM原理和调优有一定的了解；熟悉面向对象设计开发;了解数据结构与算法，熟练使用设计模式;</li>
<li>熟悉数据库原理和技术，熟练掌握 MySQL数据库和redis，对底层原理及SQL优化有一定的了解和经验;</li>
<li>熟悉spring/springboot，mybatis框架的日常使用和开发，能熟练使用nginx等中间件，对springboot的底层原理和springcloud的使用有一定的认识和了解;</li>
<li>有一定的架构经验，参与过项目中的架构设计，在高可用负载均衡系统设计，开发方面有实际经验;</li>
<li>掌握CAS单点登录，jwt， oauth2.0/spring security等安全认证相关技术，对常见用户体系，权限角色模型有一定的认识;</li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><ol>
<li><strong>深圳证券交易所</strong> - <strong>官方网站招聘模块</strong>&emsp;&emsp;(2018.08- 2018.9)<ul>
<li><strong>项目描述</strong>: 由于旧版官网技术陈旧，因此需要在深圳证券交易所新版官网的基础上重新开发招聘子模块。</li>
<li><strong>责任描述</strong>:<ul>
<li>熟悉所内的开发框架，并修复项目中的部分缺陷</li>
<li>参与项目的上线部署流程，熟悉所内网络环境以及各种工具</li>
<li>参与该模块部分业务接口的开发工作，对提交数据进行格式校验以及业务校验</li>
</ul>
</li>
</ul>
</li>
<li><strong>深圳证券交易所</strong> - <strong>信息披露国际化演示demo</strong>&emsp;&emsp;(2018.10- 2019.01) <ul>
<li><strong>项目描述</strong>: 为了响应国家一带一路政策，并且将我国证券技术系统输出至海外，我们团队负责将所内的复杂的信息披露系统简单化，国际化。做出一个可以用于演示以及宣传的信息披露demo系统，以方便商务会谈使用。</li>
<li><strong>责任描述</strong>:<ul>
<li>参与了信息披露展示系统的开发</li>
<li>参与了业务流程管理演示系统的开发</li>
<li>参与了文件传输系统的改版</li>
<li>参与技术文档以及使用说明书的编写</li>
<li>参与项目的日常部署以及缺陷修复</li>
<li>参与了后端工作流框架和部分流程处理框架的搭建，同时开发了多条流程。加深了对springboot， sso，工作流以及信息披露业务的理解</li>
</ul>
</li>
</ul>
</li>
<li><strong>深圳证券交易所</strong> - <strong>信息披露国际化系统</strong>&emsp;&emsp;(2019.02-2020.06)  <ul>
<li><strong>项目描述</strong>: 由于国内外的信息披露规则差异过大，国内的系统并不能完全照搬至国外，我们团队决定完全推翻上一个演示demo的设计思路，重新设计一个信息披露通用国际化产品。并且为了避免不必要的知识产权纠纷，将部分框架更换为拥有较为宽松的开源协议的技术框架。</li>
<li><strong>责任描述</strong>:<ul>
<li>参与了前期信息披露通用国际化产品的构思与设想</li>
<li>负责排查项目中的开源协议，并对部分开源组件进行替换与修改</li>
<li>深度参与信息披露国际化产品的需求讨论与架构设计，并进行技术验证</li>
<li>参与工作流框架的选型以及poc验证</li>
<li>负责搭建信息披露国际化产品的开发测试等各种环境，并负责日常的上线部署与维护</li>
<li>协助开发经理进行信息披露国际化产品的基础框架搭建</li>
<li>负责信息披露国际化产品SSO系统的设计与开发：引入ldap并与现有系统的用户管理模块对接，支持多种方式多种平台登录</li>
<li>负责部分业务流程的开发，以及对所实现模块进行代码评审和优化</li>
<li>参与了信息披露展示系统，业务流程管理系统，配置管理系统的业务开发</li>
<li>负责linux环境下自动部署备份脚本的编写</li>
<li>负责信息披露国际化产品的部署文档，运维文档，开发文档的编写以及部分文档的初稿翻译</li>
<li>参与了外宾的接待以及后续的技术支持与培训工作</li>
</ul>
</li>
</ul>
</li>
<li><strong>深圳证券交易所</strong> - <strong>科技与知识产权交易中心系统</strong>&emsp;&emsp;(2020.06- 至今)<ul>
<li><strong>项目描述</strong>: 为了配合广东省的建设全国知识产权交易中心的战略实施重点，大力推进知识产权质押融资、专利保险、产业基金等多项工作，同时推动建立深圳市的知识产权交易机制，实现交易双方快速匹配，降低交易成本。因此正在建设该科技与知识产权交易中心的核心系统。</li>
<li><strong>责任描述</strong>:<ul>
<li>配合开发经理完成核心系统的项目架构设计与搭建</li>
<li>负责项目的日常部署，环境维护，上线，线上问题处理以及部分技术文档编写</li>
<li>负责项目的用户体系的设计与开发</li>
<li>负责项目的安全漏洞修复</li>
<li>负责项目的部分业务模块，流程，以及专区的开发</li>
<li>负责单点登录系统与移动端登陆，扫码登陆等功能的开发，以及与vnext，区块链，人脸识别等外部系统集成并对接</li>
<li>参与代码评审与数据库评审，并负责对部分模块和框架进行优化</li>
<li>负责官网系统与业务系统部分业务模块的整体设计与开发</li>
<li>负责新版认证系统开发，引入spring security 和oauth2.0</li>
<li>学习网易轻舟微服务框架并接收培训，尝试将项目整体迁移改造至网易轻舟微服务平台</li>
<li>学习容器化技术，探索将项目容器化并采用k8s进行管理的可能性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="获奖经历"><a href="#获奖经历" class="headerlink" title="获奖经历"></a>获奖经历</h2><ul>
<li>研发部门季度之星两次</li>
<li>深圳证券交易所技术口2020进步最快新人奖</li>
</ul>
<h2 id="个人账号"><a href="#个人账号" class="headerlink" title="个人账号"></a>个人账号</h2><ul>
<li>blog 地址: <a href="https://magikarpll.com/">https://magikarpll.com/</a> (建立不久，最近才开始写技术分享)</li>
</ul>
<h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><ul>
<li>喜欢钻研技术，目前正在学习Go和k8s</li>
<li>当过小组长，有一定的项目管理和任务安排经验</li>
<li>喜欢徒步，摄影与旅游</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://magikarpll.com/2021/08/17/resume/" data-id="ckt1qkavu00050cvrhdp3g7ig" data-title="resume" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E4%B9%8Bspring-security-oauth%EF%BC%88%E4%BA%8C%EF%BC%89/">微服务认证方案设计之spring-security-oauth（二）</a>
          </li>
        
          <li>
            <a href="/2021/09/01/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/">信息系统中的统一身份认证与授权（一）</a>
          </li>
        
          <li>
            <a href="/2021/08/17/%E5%B7%A5%E4%BD%9C%E5%87%86%E5%A4%87/">工作准备</a>
          </li>
        
          <li>
            <a href="/2021/08/17/%E4%BA%8C%E5%8D%81%E4%B8%8D%E6%83%91/">二十不惑</a>
          </li>
        
          <li>
            <a href="/2021/08/17/%E5%86%99%E5%9C%A82020%E5%B9%B4%E7%9A%84%E8%AF%9D/">写在2020年的话</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 MagikarpLL<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>